![alt text](images/check.png "XCTest Checkmark")

# Unit Tests 101 - iOS ü§ì

## Por que eu devo testar?

N√£o √© preciso escrever muito para convencer sobre a import√¢ncia de testes unit√°rios em um app. Se voc√™ programa h√° algum tempo, j√° passou por um daqueles momentos em que √© preciso fazer v√°rias altera√ß√µes em uma parte do c√≥digo e fica aquele frio na barriga porque n√£o tem nada garantindo que o c√≥digo que voc√™ alterou estava relacionado - magicamente? - com v√°rias outras partes do app, que j√° n√£o v√£o mais funcionar como deveriam. Nessas horas, uma boa cobertura de testes faz muito bem pra nossa sa√∫de mental e card√≠aca, para o app e para os usu√°rios.

Se voc√™ n√£o programa h√° muito tempo, talvez ainda n√£o tenha sentido falta dos testes unit√°rios. Nesse caso, voc√™ pode escolher acreditar que eles fazem bem e se proteger ou esperar para aprender com a vida. Ambas as abordagens t√™m vantagens e desvantagens. Eu sugeriria a primeira, mas no fim das contas, _it's up to you_.

## Testes unit√°rios != TDD && Testes unit√°rios != Testes de UI

√â importante diferenciar "testes unit√°rios" de "TDD" e "Testes de UI" --  esses s√£o termos que voc√™ provavelmente vai encontrar por a√≠ enquanto estiver pesquisando por testes. Os *testes unit√°rios* servem para verificar se cada _unidade_ (classe, struct, enum, etc.) est√° funcionando da maneira que deveria. A ideia b√°sica √© criar um ambiente controlado (substituindo os objetos ou _value types_ com os quais ela se relaciona por mocks, stubs, etc.) onde √© poss√≠vel observar o comportamento dessa classe (verificar se os m√©todos que deveriam ter sido chamados foram chamados e se as properties que deveriam ter sido alteradas foram alteradas).

Quando falamos de "TDD" estamos nos referindo a uma *metodologia* de desenvolvimento. √â um _jeito de fazer as coisas_. Funciona mais ou menos assim: antes de escrever o c√≥digo para implementar uma dada feature, voc√™ deve escrever os testes unit√°rios pra esse c√≥digo. Uma vez escritos os testes - que obviamente n√£o v√£o passar! - voc√™ deve implementar a feature, fazendo com que os testes passem. Depois disso voc√™ deve refatorar o c√≥digo sabendo que se voc√™ fizer alguma besteira os testes v√£o te avisar.

Os Testes de UI s√£o bem diferentes. Neles voc√™ "v√™" o seu app pelo lado de fora. Voc√™ interage com o app como um usu√°rio, com touches, swipes, etc. e verifica se os elementos que deveriam aparecer aparecem e se as altera√ß√µes est√£o de acordo com o comportamento esperado. N√£o s√£o as _unidades_ que s√£o testadas e sim o _comportamento_ do app como um todo.

Nesse tutorial a gente vai falar de *Testes Unit√°rios* -- em breve a gente deve ter por aqui alguns artigos sobre UI Tests e TDD.

## Testando as unidades

Como eu mencionei acima, a ideia de um teste unit√°rio √© garantir que uma classe ou value type est√° funcionando como deveria, ou seja, quando chamamos um determinado m√©todo, com determinados par√¢metros, os diferentes objetos e structs com os quais ela se relacionam ter√£o os seus m√©todos chamados com os par√¢metros certos. S√£o tr√™s As: _Arrange_, _Act_ e _Assert_.

Imagina a seguinte classe:

```swift
class ViewController {
    
    var messagePresenter: MessagePresenter? // MessagePresenter √© um protocol üòâ

    override func viewDidLoad() {
        super.viewDidLoad()
        messagePresenter = AlertMessagePresenter()
    }

    func displayAlert() {
        messagePresenter?.presentMessage("Something happened!", on: self)
    }

}
```

Para testar o `ViewController` √© preciso garantir duas coisas: (1) que ap√≥s o `viewDidLoad` o `messagePresenter` ter√° sido inicializado, (2) que ao chamar o m√©todo `displayAlert` o `messagePresenter` ter√° o m√©todo `presentMessage` chamado e os par√¢metros passados para o `messagePresenter` est√£o corretos.

Um pouco de m√£o-na-massa pra tudo isso fazer sentido.

### Xcode üíö

~~Quase~~ tudo relacionado aos nossos testes est√° no "Tests Navigator".

![alt text](images/navigator.png "Test Navigator")

Ao selecionar essa tab, voc√™ vai achar um bot√£o de adicionar na parte de baixo da tela √† esquerda.

![alt text](images/addButton.png "Create New Test Class")

Crie uma nova "Classe de Teste" chamada `ViewControllerTests`. Em geral as classes de teste t√™m o nome da classe que elas v√£o testar + "Tests".
Os m√©todos de teste devem come√ßar com `test..` e n√£o devem receber nenhum par√¢metro e n√£o devem retornar nada:

```swift
func testSomething() {
    // ...
}
```

Os m√©todos `setUp` e `tearDown` s√£o sempre chamados antes e depois de cada teste, respectivamente. No nosso exemplo eles n√£o v√£o ser necess√°rios.

‚ö†Ô∏è N√£o deixe de importar o seu target no arquivo de testes:

```swift
import XCTest
@testable import TutorialUnitTests // sem esse import o seu projeto n√£o fica vis√≠vel aqui!!!
```

### Let's do our bestest (best + test, got it? üòú)

Vamos come√ßar com o b√°sico. Ap√≥s o `viewDidLoad` o view controller deve ter inicializado o seu `messagePresenter`. Vamos testar se isso est√° acontecendo:

```swift
    func testLoading() {
        // Arrange
        guard let sut = getViewController() else { return } // `sut` √© uma conven√ß√£o: Subject Under Test
        
        // Act
        _ = sut.view
        
        // Assert
        XCTAssert(sut.messagePresenter != nil, "It should have initialized its messagePresenter.")
    }
```

Para facilitar as coisas, eu coloquei um storyboard identifier no viewController e criei um metodozinho bem simples que cria o viewController para ser testado:

```swift
    func getViewController() -> ViewController? {
        guard let vc = UIStoryboard(name: "Main", bundle: nil).instantiateViewController(withIdentifier: "SimpleVC") as? ViewController else {
                XCTAssert(false, "No viewController with that identifier")
                return nil
        }
        return vc
    }

```

O "arrange" e o "act" nesse caso s√£o bem simples. Basta criar o `viewController` e chamar a property `view` e o m√©todo `viewDidLoad` ser√° chamado (isso acontece porque no `getter` da `view` o `viewController` chama o m√©todo `loadView` e ao final desse m√©todo o `viewDidLoad` √© chamado).

Para verificar se tudo aconteceu como devia n√≥s chamamos a fun√ß√£o `XCTAssert` que recebe uma express√£o que deve resultar em um `Bool` e uma mensagem que ser√° exibida se o teste falhar.

Execute o teste clicando no losango √† esquerda da assinatura do teste ou com os atalhos (`cmd + u` para executar todos os testes ou `cmd + option + ctrl + u` para executar o arquivo atual de testes). Se tudo estiver certo, o teste deve passar e o losango ficar√° verde com um check branco ‚úÖ. Para validar que o teste funciona de fato voc√™ pode comentar a linha onde o `messagePresenter` √© inicializado e rodar os testes novamente. O teste deve falhar e o losango vai ficar vermelho com um "x". Se isso n√£o acontecer, chame os bombeiros! üöí üë®üèª‚Äçüöí üî• Alguma coisa est√° fora do lugar.

### A little further

Agora, vamos para um teste um pouco menos simples.

Antes de tudo, n√≥s devemos criar um ambiente que permita a observa√ß√£o do comportamento da unidade que queremos testar. Isso significa substituir os objetos com os quais ela se relaciona por outros objetos "semelhantes" que nos permitam verificar de que modo a classe que est√° sendo testada interagiu com eles.

Existem v√°rias ferramentas para ajudar na cria√ß√£o desse "ambiente", especialmente para Objective-C. Em swift eles n√£o s√£o nem t√£o abundantes nem t√£o necess√°rios. Usar protocolos pra definir as abstra√ß√µes de cada tipo permite que seja muito simples criar um Mock para qualquer classe ou value type.

No nosso caso, vamos criar um `MockMessagePresenter` que deve nos mostrar tr√™s coisas: (1) se o m√©todo foi chamado; (2) se a mensagem passada foi "Something happened"; e (3) se o view controller passado foi o view controller que chamou o m√©todo.

```swift
class MockMessagePresenter: MessagePresenter {
    
    var presentCalled = false
    var message: String?
    var viewController: UIViewController?
    
    func presentMessage(_ message: String, on viewController: UIViewController) {
        presentCalled = true
        self.message = message
        self.viewController = viewController
    }
    
}

```

No nosso teste n√≥s precisamos criar um viewController e passar para ele um `MockMessagePresenter`. Desta forma, quando chamarmos o `displayAlert` o viewController ir√° interagir com o nosso Mock e n√≥s poderemos ver se tudo ocorreu como esperado.

O nosso teste fica mais ou menos assim: 

```swift
func testCallingPresenter() {
        // Arrange
        guard let sut = getViewController() else { return }
        let messagePresenter = MockMessagePresenter()
        sut.messagePresenter = messagePresenter
        
        // Act
        sut.displayAlert()
        
        // Assert
        XCTAssert(messagePresenter.presentCalled, "It should have called presentMessage()")
        XCTAssert(messagePresenter.message == "Something happened!", "It should have passed the right message.")
        XCTAssert(messagePresenter.viewController == sut, "It should the right viewController.")
        
    }

```

Rode os testes e veja se est√° tudo bem.

Voc√™ pode alterar os par√¢metros e "testar" o teste - n√£o adianta nada ter um teste que n√£o falhe quando algo est√° errado! Comente a chamada do m√©todo, passe par√¢metros errados e veja se o seu teste vai apontar os problemas.

Como voc√™ deve ter notado, esses dois testes simples garantem que o nosso viewController est√° funcionando como deveria. Isso nos d√° a seguran√ßa de que, se algum dia, sem querer, algu√©m apagar o `viewDidLoad` ou alterar os par√¢metros no `presentMessage` os testes v√£o avisar. Obviamente, no nosso exemplo daria pra notar isso olhando para o c√≥digo, mas voc√™ pode imaginar como seria diferente em uma classe com algumas centenas de linhas de c√≥digo, que cont√©m v√°rias chamadas importantes na superclasse, por exemplo. Os testes permitem que a manuten√ß√£o no c√≥digo seja uma atividade segura. üë∑üèª

## Uma nota sobre "arquitetura" üèõ

Voc√™ deve ter notado que o teste s√≥ foi poss√≠vel porque n√≥s t√≠nhamos como substituir o `messagePresenter` por um outro objeto com a nossa implementa√ß√£o. Tente imaginar como n√≥s far√≠amos isso se n√£o houvesse uma property `messagePresenter` no view controller e, em vez disso, o m√©todo `displayAlert` tivesse a seguinte implementa√ß√£o:

```swift
func displayAlert() {
    let messagePresenter = AlertMessagePresenter()
    messagePresenter.presentMessage("Something happened!", on: self)
}
```

O objeto com o qual a classe se relaciona √© criado dentro do m√©todo e deixa de existir assim que o m√©todo retorna. N√£o seria poss√≠vel testar o funcinamento do view controller sem depender do funcionamento de outras unidades ([Dependency Injection](https://en.wikipedia.org/wiki/Dependency_injection)). Por isso, √© importante que o nosso c√≥digo seja criado de modo que possibilite testar cada unidade separadamente. S√≥ esse "mind set" j√° tornar√° o c√≥digo bem mais limpo e f√°cil de manter, al√©m do j√° mencionado benef√≠cio de poder "brincar" tranquilamente sabendo que os testes v√£o nos avisar se fizermos alguma besteira.

## N√£o deixe de ler:

* [A Pragmatic Approach to iOS Testing, do Orta Therox](https://github.com/orta/pragmatic-testing)
