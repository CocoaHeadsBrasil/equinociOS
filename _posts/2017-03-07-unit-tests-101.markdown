---
layout:     post
title:      "Unit Tests 101"
subtitle:   "Primeir[Ã­ssim]os passos"
date:       2017-03-07 00:00:00
author:     "Emannuel Carvalho"
header-img: "img/emannuelOC/header.jpg"
category:   Testes
---

## Por que eu devo testar?

NÃ£o Ã© preciso escrever muito para convencer sobre a importÃ¢ncia de testes unitÃ¡rios em um app. Se vocÃª programa hÃ¡ algum tempo, jÃ¡ passou por um daqueles momentos em que Ã© preciso fazer vÃ¡rias alteraÃ§Ãµes em uma parte do cÃ³digo e fica aquele frio na barriga porque nÃ£o tem nada garantindo que o cÃ³digo que vocÃª alterou nÃ£o vai quebrar outras partes com as quais ele estÃ¡ relacionado. Nessas horas, uma boa cobertura de testes faz muito bem para o app e para os usuÃ¡rios - e tambÃ©m pra nossa saÃºde mental e cardÃ­aca.
 
Se vocÃª nÃ£o programa hÃ¡ muito tempo, talvez ainda nÃ£o tenha sentido falta dos testes unitÃ¡rios. Nesse caso, vocÃª pode escolher acreditar que eles fazem bem e se proteger ou esperar para aprender com a vida. Ambas as abordagens tÃªm vantagens e desvantagens. Eu sugeriria a primeira, mas no fim das contas, _it's up to you_.

## Testes unitÃ¡rios x TDD x Testes de UI

Ã‰ importante diferenciar "testes unitÃ¡rios" de "TDD" e "Testes de UI" -  esses sÃ£o termos que vocÃª provavelmente vai encontrar por aÃ­ enquanto estiver pesquisando por testes. Os *testes unitÃ¡rios* servem para verificar se cada _unidade_ (classe, struct, enum) estÃ¡ funcionando da maneira que deveria. A ideia bÃ¡sica Ã© criar um ambiente controlado (substituindo os objetos ou _value types_ com os quais ela se relaciona por mocks, stubs, etc.) onde Ã© possÃ­vel observar o comportamento dessa classe (verificar se os mÃ©todos que deveriam ter sido chamados foram chamados e se as properties que deveriam ter sido alteradas foram alteradas).

Quando falamos de "TDD" estamos nos referindo a uma *metodologia* de desenvolvimento. Ã‰ um _jeito de fazer as coisas_. Funciona mais ou menos assim: antes de escrever o cÃ³digo para implementar uma dada feature, vocÃª deve escrever os testes unitÃ¡rios pra esse cÃ³digo. Uma vez escritos os testes - que obviamente nÃ£o vÃ£o passar! - vocÃª deve implementar a feature, fazendo com que os testes passem. Depois disso vocÃª deve refatorar o cÃ³digo sabendo que se vocÃª fizer alguma besteira os testes vÃ£o te avisar.

Os Testes de UI sÃ£o bem diferentes. Neles vocÃª "vÃª" o seu app pelo lado de fora. VocÃª interage com o app como um usuÃ¡rio, com touches, swipes, etc. e verifica se os elementos que deveriam aparecer aparecem e se as alteraÃ§Ãµes estÃ£o de acordo com o comportamento esperado. NÃ£o sÃ£o as _unidades_ que sÃ£o testadas e sim o _comportamento_ do app como um todo.

Nesse post a gente vai falar de *Testes UnitÃ¡rios*.

## Testando as unidades

Como eu mencionei acima, a ideia de um teste unitÃ¡rio Ã© garantir que uma classe ou value type estÃ¡ funcionando como deveria, ou seja, quando chamamos um determinado mÃ©todo, com determinados parÃ¢metros, os diferentes objetos com os quais ela se relaciona terÃ£o os seus mÃ©todos chamados com os parÃ¢metros certos. SÃ£o trÃªs A's: _Arrange_, _Act_ e _Assert_.

Imagina a seguinte classe:

```swift
class ViewController {
    
    var messagePresenter: MessagePresenter? // MessagePresenter Ã© um protocol ğŸ˜‰

    override func viewDidLoad() {
        super.viewDidLoad()
        messagePresenter = AlertMessagePresenter() // O AlertMessagePresenter implementa o protocolo MessagePresenter
    }

    func displayAlert() {
        messagePresenter?.presentMessage("Something happened!", on: self)
    }

}
```

Para testar o `ViewController` Ã© preciso garantir duas coisas: (1) que apÃ³s o `viewDidLoad` o `messagePresenter` terÃ¡ sido inicializado, (2) que, ao chamar o mÃ©todo `displayAlert`, o mÃ©todo `presentMessage` serÃ¡ chamado no `messagePresenter` e os parÃ¢metros foram passados corretamente.

Um pouco de mÃ£o-na-massa pra tudo isso fazer sentido.

âš ï¸ Nesse post eu vou mostrar um exemplo de testes usando XCTests. Existem outras ferramentas para testes unitÃ¡rios em iOS, mas a ideia geral Ã© basicamente a mesma.
Se vocÃª quiser seguir os passos a seguir, tem um projeto [aqui](https://github.com/emannuelOC/tutorial_unit_tests){:target="_blank"} esperando para ser testado ğŸ¤“.

### Xcode ğŸ’š

~~Quase~~ tudo relacionado aos nossos testes estÃ¡ no "Tests Navigator", do lado esquerdo lÃ¡ em cima.

<img src="{{ site.baseurl }}/img/emannuelOC/tests_navigator.png">

Ao selecionar essa tab, vocÃª vai achar um botÃ£o de adicionar na parte de baixo da tela Ã  esquerda.

<img src="{{ site.baseurl }}/img/emannuelOC/new_test_class.png">

Crie uma nova "Classe de Teste" chamada `ViewControllerTests`, subclasse de `XCTestCase`. Em geral as classes de teste tÃªm o nome da classe que elas vÃ£o testar + "Tests".
Os mÃ©todos de teste devem comeÃ§ar com `test..`; nÃ£o devem receber nenhum parÃ¢metro e nÃ£o devem retornar nada:

```swift
func testSomething() {
    // ...
}
```

Os mÃ©todos `setUp` e `tearDown` sÃ£o sempre chamados antes e depois de cada teste, respectivamente. No nosso exemplo eles nÃ£o vÃ£o ser necessÃ¡rios.

âš ï¸ NÃ£o deixe de importar o seu target no arquivo de testes:

```swift
import XCTest
@testable import TutorialUnitTests // sem esse import o seu projeto nÃ£o fica visÃ­vel aqui!!!
```

### Let's do our bestest (best + test, got it? ğŸ˜œ)

Vamos comeÃ§ar com o bÃ¡sico. ApÃ³s o `viewDidLoad` o view controller deve ter inicializado o seu `messagePresenter`. Vamos testar se isso estÃ¡ acontecendo:

```swift
func testLoading() {
    // Arrange
    guard let sut = getViewController() else { return } // `sut` Ã© uma convenÃ§Ã£o: Subject Under Test
        
    // Act
    _ = sut.view
        
    // Assert
    XCTAssertNotNil(sut.messagePresenter, "It should have initialized its messagePresenter.")
}
```

Para facilitar as coisas, eu coloquei um storyboard identifier no `viewController` e criei um metodozinho bem simples que cria o viewController para ser testado:

```swift
func getViewController() -> ViewController? {
    guard let vc = UIStoryboard(name: "Main", bundle: nil).instantiateViewController(withIdentifier: "SimpleVC") as? ViewController else {
        XCTAssert(false, "No viewController with that identifier")
        return nil
    }
    return vc
}

```

O "arrange" e o "act" nesse caso sÃ£o bem simples. Basta criar o `viewController` e chamar a property `view` e o mÃ©todo `viewDidLoad` serÃ¡ chamado (isso acontece porque no getter da `view` o `viewController` chama o mÃ©todo `loadView` e ao final desse mÃ©todo o `viewDidLoad` Ã© chamado).

Para verificar se tudo aconteceu como deveria nÃ³s chamamos a funÃ§Ã£o `XCTAssertNotNil` que recebe uma expressÃ£o e uma mensagem que serÃ¡ exibida se o teste falhar - ou seja, se a expressÃ£o passada for `nil`. A funÃ§Ã£o mais bÃ¡sica, `XCTAssert`, que recebe um `Bool` tem diferentes variantes: `XCTAssertNotNil`, `XCTAssertEqual`, etc.

Execute o teste clicando no losango Ã  esquerda da assinatura do teste ou com os atalhos (`cmd + u` para executar todos os testes ou `cmd + option + ctrl + u` para executar o arquivo atual de testes). Se tudo estiver certo, o teste deve passar e o losango ficarÃ¡ verde com um check branco âœ…. Para validar que o teste funciona de fato vocÃª pode comentar a linha onde o `messagePresenter` Ã© inicializado na classe `ViewController` e rodar os testes novamente. O teste deve falhar e o losango vai ficar vermelho com um "x". Se isso nÃ£o acontecer, chame os bombeiros! ğŸš’ ğŸ‘¨ğŸ»â€ğŸš’ ğŸ”¥ Alguma coisa estÃ¡ fora do lugar.

### A little further

Agora, vamos para um teste um pouco menos simples.

Antes de tudo, nÃ³s devemos criar um ambiente que permita a observaÃ§Ã£o do comportamento da unidade que queremos testar. Isso significa substituir os objetos com os quais ela se relaciona por outros objetos "semelhantes" que nos permitam verificar de que modo a classe que estÃ¡ sendo testada interagiu com eles.

Existem vÃ¡rias ferramentas para ajudar na criaÃ§Ã£o desse "ambiente", especialmente para Objective-C. Em swift eles nÃ£o sÃ£o nem tÃ£o abundantes nem tÃ£o necessÃ¡rios. Usar protocolos pra definir as abstraÃ§Ãµes de cada tipo permite que seja muito simples criar um Mock para qualquer classe ou value type.

No nosso caso, vamos criar um `MockMessagePresenter` que deve nos mostrar trÃªs coisas: (1) se o mÃ©todo foi chamado; (2) se a mensagem passada foi "Something happened"; e (3) se o view controller passado foi o view controller que chamou o mÃ©todo.

```swift
class MockMessagePresenter: MessagePresenter {
    
    var presentCalled = false
    var message: String?
    var viewController: UIViewController?
    
    func presentMessage(_ message: String, on viewController: UIViewController) {
        presentCalled = true
        self.message = message
        self.viewController = viewController
    }
    
}

```

No nosso teste nÃ³s precisamos criar um viewController e passar para ele um `MockMessagePresenter`. Desta forma, quando chamarmos o `displayAlert` o viewController irÃ¡ interagir com o nosso Mock e nÃ³s poderemos ver se tudo ocorreu como esperado.

O nosso teste fica mais ou menos assim: 

```swift
func testCallingPresenter() {
        // Arrange
        guard let sut = getViewController() else { return }
        let messagePresenter = MockMessagePresenter()
        sut.messagePresenter = messagePresenter
        
        // Act
        sut.displayAlert()
        
        // Assert
        XCTAssert(messagePresenter.presentCalled, "It should have called presentMessage()")
        XCTAssert(messagePresenter.message == "Something happened!", "It should have passed the right message.")
        XCTAssert(messagePresenter.viewController == sut, "It should the right viewController.")
        
    }

```

Rode os testes e veja se estÃ¡ tudo bem.

VocÃª pode alterar os parÃ¢metros e "testar" o teste - nÃ£o adianta nada ter um teste que nÃ£o falhe quando algo estÃ¡ errado! Comente a chamada do mÃ©todo, passe parÃ¢metros errados e veja se o seu teste vai apontar os problemas.

Como vocÃª deve ter notado, esses dois testes simples garantem que o nosso viewController estÃ¡ funcionando como deveria. Isso nos dÃ¡ a seguranÃ§a de que, se algum dia, sem querer, alguÃ©m apagar o `viewDidLoad` ou alterar os parÃ¢metros no `presentMessage` os testes vÃ£o avisar. Obviamente, no nosso exemplo daria pra notar isso olhando para o cÃ³digo, mas vocÃª pode imaginar como seria diferente em uma classe com algumas centenas de linhas de cÃ³digo, que contÃ©m vÃ¡rias chamadas importantes na superclasse, por exemplo. Os testes permitem que a manutenÃ§Ã£o no cÃ³digo seja uma atividade segura. ğŸ‘·ğŸ»

## Uma nota sobre "arquitetura" ğŸ›

VocÃª deve ter notado que o teste sÃ³ foi possÃ­vel porque nÃ³s tÃ­nhamos como substituir o `messagePresenter` por um outro objeto com a nossa implementaÃ§Ã£o. Tente imaginar como nÃ³s farÃ­amos isso se nÃ£o houvesse uma property `messagePresenter` no view controller e, em vez disso, o mÃ©todo `displayAlert` tivesse a seguinte implementaÃ§Ã£o:

```swift
func displayAlert() {
    let messagePresenter = AlertMessagePresenter()
    messagePresenter.presentMessage("Something happened!", on: self)
}
```

O objeto com o qual a classe se relaciona Ã© criado dentro do mÃ©todo e deixa de existir assim que o mÃ©todo retorna. NÃ£o seria possÃ­vel testar o funcinamento do view controller sem depender do funcionamento de outras unidades. Por isso, Ã© importante que o nosso cÃ³digo seja criado de modo que possibilite testar cada unidade separadamente ([Dependency Injection](https://en.wikipedia.org/wiki/Dependency_injection)). SÃ³ esse jeito de pensar jÃ¡ tornarÃ¡ o cÃ³digo bem mais limpo e fÃ¡cil de manter, alÃ©m do jÃ¡ mencionado benefÃ­cio de poder "brincar" tranquilamente sabendo que os testes vÃ£o nos avisar se fizermos alguma besteira.

## NÃ£o deixe de ler:

* [A Pragmatic Approach to iOS Testing, do Orta Therox](https://github.com/orta/pragmatic-testing)
